// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "SemanticSearchService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "Common/lib4/ConfigFile.hpp"
#include "Common/lib4/FileName.hpp"
#include "Common/lib4/Time.hpp"
#include "Common/lib4/File.hpp"
#include "Common/lib4/System.hpp"
//#include "ChatControler/ChatResponse.h"
//#include "ChatControler/SemanticListResponse.hpp"
#include "CustomerServiceChat/ChatEngine.h"
#include "Common/lib5/WHL_LogInstance.hpp"

#include "Common/LicenceValidator.hpp"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

namespace aisms{
	aisms::GOption gOption;
}

class SemanticSearchServiceHandler : virtual public SemanticSearchServiceIf {
 public:
	SemanticSearchServiceHandler(const acl::FileName& sConfigFile, int port) {
    	// Your initialization goes here
		pthread_mutex_init(&m_mutex, NULL);
		pthread_mutex_lock(&m_mutex);
		m_nProcessing = true;

		acl::ConfigFile config;
		config.setCommentMarks("#");
		if(config.read(sConfigFile) == false){
			ELOGGER->print(true, "ERROR: Can't read config file [%s]\n", sConfigFile.c_str());
			exit(1);
		}

		// 读取返回XML模板
		/*acl::FileName sResponseXml = config.getValue("ResponseXml");
		if(sResponseXml.empty()){
			PRINT("Init Chat reponse error!")
			exit(6);
		}else{
			sResponseXml = sConfigFile.getPath()+ "/" + sResponseXml;
			if(m_chatResponse.init(sResponseXml) == false){
				LOG_FAILE_CALL_PARAM("Server::Server", "m_chatResponse.init", sResponseXml.c_str());
				exit(6);
			}
		}*/

		// 读取输入提示XML模板
		m_sHintXml = config.getValue("HintXml");
		if(m_sHintXml.empty()){
			ELOGGER->print(true, "ERROR: [HintXml] is not defined in file [%s]\n", m_sHintXml.c_str());			
			exit(4);
		}else{
			m_sHintXml = sConfigFile.getPath()+ "/" + m_sHintXml;
		}

		// 初始化对话引擎
		if(m_engine.init(sConfigFile) == false){
			ELOGGER->print(true, "Server::Server m_engine.init file [%s] fail.\n", sConfigFile.c_str());					
			exit(2);
		}

		int nPid = getpid();
		std::stringstream ss;
		ss<<"server."<<port<<".pid";
		std::ofstream out(ss.str().c_str(), std::ios::out);
		out<<nPid<<std::endl;
		out.close();

		m_nProcessing = false;

		pthread_mutex_unlock(&m_mutex);
}

	void engineChat(std::string& _return, const std::string& sXml) {
		// Your implementation goes here
		pthread_mutex_lock(&m_mutex);
		m_nProcessing = true;
		_return = generateResultByAnalyzeEngineChatXml(sXml);
		m_nProcessing = false;
		pthread_mutex_unlock(&m_mutex);
	}

	void getSemanticList(std::string& _return, const std::string& sXml) {
		_return = "暂不支持此接口";
	}

	void getHint(std::string& _return, const std::string& sXml) {
		// Your implementation goes here
		pthread_mutex_lock(&m_mutex);
		m_nProcessing = true;
		_return = generateResultByAnalzeGetHintXml(sXml);
		m_nProcessing = false;
		pthread_mutex_unlock(&m_mutex);
   }

	void getRelate(std::string& _return, const std::string& sXml) {
		_return = "暂不支持此接口";
    }

	int32_t isBusy() {
    	// Your implementation goes here
		//PRINT("[Message] I am "<<(m_nProcessing==true ? "Busy" : "Free"))
		ELOGGER->print(true, "I am %s.\n", (m_nProcessing==true ? "Busy" : "Free"));			
		return (m_nProcessing==true ? 1 : 0);
	}

private:
	std::string generateResultByAnalzeGetHintXml(const std::string& sXml){
		robosay::XmlParser xmlRequest;

		if(xmlRequest.parse(sXml) == false){				
			ELOGGER->print(true, "generateResultByAnalzeGetHintXml:Input XML format error!");
			return "Input XML format error!";
		}
		std::string sInput = xmlRequest.getXPathValue("//chat/question/content");
		std::vector<std::string> vHint;
		if(sInput.empty()){
			ELOGGER->print(true, "generateResultByAnalzeGetHintXml:input is empty!");			
		}else{
			PRINT(sInput)
			vHint = m_engine.getPromptInfo(sInput);
		}
		robosay::XmlParser xmlResult;
		xmlResult.read(m_sHintXml);
		xmlResult.setXPathValue("/hint_response/way", xmlRequest.getXPathValue("//chat/way"));
		xmlResult.setXPathValue("/hint_response/from_user", xmlRequest.getXPathValue("//chat/to_user"));
		xmlResult.setXPathValue("/hint_response/to_user", xmlRequest.getXPathValue("//chat/from_user"));
		if(!vHint.empty()){
			std::stringstream ss;
			for(size_t i=0; i < vHint.size(); i++){
				ss.str("");
				xmlResult.insertNode("/hint_response/hint_list","hint", "");
				ss<<"/hint_response/hint_list/hint["<<i+1<<"]";
				xmlResult.setXPathCDataValue(ss.str(), vHint[i]);
			}
		}else{
			ELOGGER->print(true, "generateResultByAnalzeGetHintXml:Hint information is empty!");			
		}
		return xmlResult.toStr();
	}

	/*std::string generateResultByAnalyzeGetRelateXml(const std::string sXml){

		std::string sChatID;
		std::string sInput = getInput(sXml, sChatID);
		std::vector<std::string> vRelate;
		if(sInput.empty()){
			PRINT("input is empty")
		}else{
			PRINT(sInput)
			vRelate = m_engine.getRelateInfo(sInput);
		}
		robosay::XmlParser xmlResult;
		xmlResult.read(m_sRelateQXml);
		if(!sChatID.empty()){
			xmlResult.setXPathValue("//GetRelate/ChatID",sChatID);
		}
		if(!vRelate.empty()){
			PRINT(vRelate.size())
			for(size_t i=0; i < vRelate.size(); i++){
				xmlResult.insertNode("//GetRelate/RelateList", "Relate", vRelate[i]);
			}
		}else{
			PRINT("RELATE INFORMATION IS EMPTY")
		}
		return xmlResult.toStr();
	}*/

	std::string generateResultByAnalyzeEngineChatXml(const std::string& sXml){
		// 记录输入的XML
		std::ofstream ofs("inKey.xml",std::ios::out);
		ofs << sXml << std::endl;
		ofs.close();

		robosay::XmlParser xmlRequest;

		if(xmlRequest.parse(sXml) == false){
			ELOGGER->print(true, "generateResultByAnalyzeEngineChatXml:Input XML format error!");
			return "Input XML format error!";
		}
	
		std::string sInput = xmlRequest.getXPathValue("//chat/question/content");
		std::string sContext = xmlRequest.getXPathValue("//chat/context");
		std::string sWay = xmlRequest.getXPathValue("//chat/way");

		if(sInput.empty()){
			ELOGGER->print(true, "generateResultByAnalyzeEngineChatXml:Input is empty!");
			return "//chat/question/content is empty";
		}

		ELOGGER->print(true, "question is [%s]\n", sInput.c_str());
		ELOGGER->print(true, "context is [%s]\n", sContext.c_str());		
        Result_info resultInfo;
        std::string sBeginTime = acl::Time::getCurrentTime();

        bool bRet = m_engine.process(sInput,true, sContext, resultInfo,sWay);
        if(!bRet){
			ELOGGER->print(true, "generateResultByAnalyzeEngineChatXml:Failed to call m_engine.process!");
        }
		ELOGGER->print(true, "Answer is [%s]\n", resultInfo.m_answer.get_answer().c_str());			
        resultInfo.m_robot.set_end_time(acl::Time::getCurrentTime());
        resultInfo.m_robot.set_beg_time(sBeginTime);
        resultInfo.m_robot.set_context("");
        // std::string sXmlResponse = m_chatResponse.generateResponse(xmlRequest, resultInfo);
        std::string sXmlResponse = resultInfo.toXml(xmlRequest,sContext);

		// 记录输入的XML
		ofs.open("outKey.xml", std::ios::out);
		ofs << sXmlResponse << std::endl;
		ofs.close();

		return sXmlResponse;
	}

	/*std::string generateResultBySearchListXml(const std::string sXml){
		robosay::XmlParser xmlRequest;

		if(xmlRequest.parse(sXml) == false){
			return m_SLResponse.genErrorResponse(xmlRequest,"Input XML format error!");
		}

		// 读取NewFlag标志
		std::string sNewFlag = xmlRequest.getXPathValue("/SemanticListRequest/NewFlag");
		if(sNewFlag == "true"){
			// deploySemanticDic
		}else if(sNewFlag != "false"){
			return m_SLResponse.genErrorResponse(xmlRequest,"Input XML node [NewFlag] error!");
		}

		// 读取知识库名称
		std::string sKBName = xmlRequest.getXPathValue("/SemanticListRequest/KBName");
		std::string sInput = xmlRequest.getXPathValue("/SemanticListRequest/Input");
		std::vector<std::string> vSemantic = m_engine.getSemanticList(sKBName, sInput);
		if(vSemantic.empty()){
			return m_SLResponse.genErrorResponse(xmlRequest,"ChatEngine::getSemanticList error!");
		}

		return m_SLResponse.genResponse(xmlRequest,vSemantic);
	}*/

private:
	robosay::base::ChatEngine m_engine;
	bool m_nProcessing;
	pthread_mutex_t m_mutex;
	acl::FileName m_sHintXml;
	acl::FileName m_sRelateQXml;
	//robosay::base::ChatResponse 	m_chatResponse;
};

int main(int argc, char **argv) {
	int port;
	
	// 读取root.conf
	acl::FileName sFileRoute;
	acl::String sPort;
	if(argc == 3){
		sFileRoute = argv[1];
		sPort = argv[2];
		port = sPort.to<int>();
	}else if(argc == 2 && strcmp(argv[1],"-v") == 0){
		std::cout<<ENGINE_VERSION<<std::endl;
		return 1;
	}else{
		port = 9000;
		sFileRoute = "../../data/root.conf";
	}

    std::string lisenceFileNamePath = "./data/lisence/rbs_licence.dat";
	LicenceValidator validator;
	if(validator.validLicence(lisenceFileNamePath) == true){
		std::cout<<"Valid licence"<<std::endl;
	}else{
		std::cout<<"happan error: Invalid licence"<<std::endl;
		return 1;
	}
	
	shared_ptr<SemanticSearchServiceHandler> handler(new SemanticSearchServiceHandler(sFileRoute, port));
	shared_ptr<TProcessor> processor(new SemanticSearchServiceProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

	P("CustomerServiceChat THRIFT_SUCCESS "<<">>  server on port "<<port)
	server.serve();
	return 0;
}

